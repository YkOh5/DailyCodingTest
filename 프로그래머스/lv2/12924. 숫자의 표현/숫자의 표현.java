// 1. 이중반복문을 쓰면 시간복잡도가 O(n^2)이 되어 효율성이 떨어지므로
// 2. 1부터 해당 원소의 인덱스까지 연속한 자연수들의 합을 원소로 갖는 배열과 Two-Pointers 알고리즘을 이용
// 3. 배열의 마지막 원소의 인덱스를 n/2 + 1로 설정하면, n으로 설정했을 때보다 더 효율적
// 4. n/2 + 1까지 고려하였으므로, p1 = p2 = n인 경우의 수 1을 더해서 반환
// 5. 단, n이 1이나 2일 때는 즉시 1을 반환

// ex) n = 15인 경우, 마지막 원소는 8(=n/2 + 1)이며
// 배열의 원소는 [0, 1, 3, 6, 10, 15, 21, 28, 36]
// 이 때 연속한 자연수들의 합이 n과 같은 경우는
// 15 - 0, 21 - 6, 36 - 2 의 3가지와 (1~n까지의 합) - (1~n-1까지의 합)의 1가지를 더한 4가지가 된다

class Solution {
    public int solution(int n) {
        int answer = 1; /* 자기 자신은 무조건 포함이므로 1부터 시작 (n 일때 n 도 포함된다) */

        /* 1부터 시작 */
        for (int i = 1; i < n; i++) {
            int sum = i;

            /* i + 1 부터 n 포함 까지 */
            for (int j = i + 1; j <= n; j++) {
                sum += j;

                if (sum == n) { /* n 일 경우 */
                    answer += 1;
                    break;
                } else if (sum > n) { /* sum 이 n 보다 커진 이후로는 해당 i의 경우가 없다고 판단 */
                    break;
                }
            }
        }

        return answer;
    }
}